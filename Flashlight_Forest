from cmu_graphics import *
import random
#Random functions: https://www.w3schools.com/python/module_random.asp
import math
#Math functions: https://docs.python.org/3/library/math.html

#Player variables
class moveableCharacter():
    def __init__(self, cx, cy, r, dx = 0, dy = 0):
        self.cx = cx
        self.cy = cy
        self.dx = dx
        self.dy = dy
        self.r = r

class label():
    def __init__(self, leftX, topY, width, height, text, shouldFill):
        self.leftX = leftX
        self.topY = topY
        self.width = width
        self.height = height
        self.text = text
        self.shouldFill = shouldFill

    def drawLabel(self, color):
        if self.shouldFill:
            drawRect(self.leftX, self.topY, self.width, self.height, fill = color, border = 'black')
        else:
            drawRect(self.leftX, self.topY, self.width, self.height, fill = None, border = 'black')
        drawLabel(self.text, self.leftX + self.width / 2, self.topY + self.height / 2)

    def pointInLabel(self, x, y):
        if self.leftX <= x <= self.leftX + self.width and self.topY <= y <= self.topY + self.height:
            return True
        return False

def onAppStart(app):
    #Board variables
    app.rows = 20
    app.cols = 19
    app.boardLeft = 50
    app.boardTop = 75
    app.boardWidth = 300
    app.boardHeight = 300
    app.treasures = 5
    app.gameMode = 'firstPerson'
    resetBoard(app)
    resetFlashlight(app)
    createButtons(app)

#Start Menu stuff
def createButtons(app):
    app.startButton = label(150, 175, 100, 50, "Start", False)
    app.instructionsButton = label(150, 235, 100, 50, "Instructions", False)
    app.gameModesButton = label(150, 295, 100, 50, "Game Modes", False)
    app.backButton = label(20, 20, 70, 20, "< Back", False)
    app.mapModeButton = label(150, 175, 100, 50, "Map Mode", False)
    app.flashlightModeButton = label(150, 235, 100, 50, "Flashlight Mode", False)
    app.firstPersonButton = label(150, 295, 100, 50, "First Person Mode", False)
    app.startButtonsList = [app.startButton, app.instructionsButton, app.gameModesButton]
    app.gameModeButtons = [app.mapModeButton, app.flashlightModeButton, app.firstPersonButton]
    app.allButtonsList = app.startButtonsList + [app.backButton] + app.gameModeButtons


def start_redrawAll(app):
    drawLabel('Flashlight Forest', 200, 50, bold = True, size = 16)
    if app.gameMode == 'firstPerson':
        drawLabel('first person mode', 200, 75)
    else:
        drawLabel(app.gameMode + ' mode', 200, 75)
    for button in app.startButtonsList:
        button.drawLabel('gray')

def instructions_redrawAll(app):
    drawLabel('Use up and down arrow keys to move, left and right arrow keys to rotate', 200, 100)
    drawLabel('Use q and e to zoom in/out', 200, 116)
    drawLabel(f'''m: map mode   f: flashlight mode''', 200, 68)    
    drawLabel('Press r to reset, i to go first-person', 200, 84)
    app.backButton.drawLabel('gray')

def gameModes_redrawAll(app):
    drawLabel('Choose your game mode', 200, 50)
    for button in app.gameModeButtons:
        button.drawLabel('gray')
    app.backButton.drawLabel('gray')

def start_onMousePress(app, mx, my):
    if app.startButton.pointInLabel(mx, my):
        setActiveScreen(app.gameMode)
    if app.instructionsButton.pointInLabel(mx, my):
        setActiveScreen('instructions')
    if app.gameModesButton.pointInLabel(mx, my):
        setActiveScreen('gameModes')

def start_onMouseMove(app, mx, my):
    for button in app.allButtonsList:
        if button.pointInLabel(mx, my):
            button.shouldFill = True
        else:
            button.shouldFill = False

def instructions_onMousePress(app, mx, my):
    if app.backButton.pointInLabel(mx, my):
        setActiveScreen('start')

def gameModes_onMousePress(app, mx, my):
    instructions_onMousePress(app, mx, my)
    if app.mapModeButton.pointInLabel(mx, my):
        app.gameMode = 'map'
        setActiveScreen('start')
    if app.firstPersonButton.pointInLabel(mx, my):
        app.gameMode = 'firstPerson'
        setActiveScreen('start')
    if app.flashlightModeButton.pointInLabel(mx, my):
        app.gameMode = 'flashlight'
        setActiveScreen('start')

def instructions_onMouseMove(app, mx, my):
    start_onMouseMove(app, mx, my)

def gameModes_onMouseMove(app, mx, my):
    start_onMouseMove(app, mx, my)

def start_onStep(app):
    pass

def instructions_onStep(app):
    pass

def gameModes_onStep(app):
    pass

#Board creation
def resetBoard(app):
    #Player variables
    cellWidth, cellHeight = getCellSize(app)
    radius = min(cellWidth, cellHeight) / 4
    app.player = moveableCharacter(app.boardLeft + (cellWidth) * 
                                    (app.cols // 2 + 0.5), app.boardTop + (cellHeight)
                                     * (app.rows // 2 + 0.5), radius)
    app.movementCoefficient = 4
    app.score = 0
    app.win = False
    #Create board
    app.cellColors = [[None for col in range(app.cols)] for row in range(app.rows)]
    app.facingAngle = -90
    fillBorders(app)
    fillBoard(app)
    generateTreasure(app, app.treasures)
    app.maxRayLength = 150
    app.arcLength = 60

def resetFlashlight(app):
    app.flashlightColors = [[None for col in range(app.cols)] for row in range(app.rows)]

def map_redrawAll(app):
    #Draw the board
    if not app.win:
        drawProgressBar(app)
        drawLabel(f'Treasures Collected: {app.score}/{app.treasures}', 200, 40)
        map_drawBoard(app)
        #Draw the player
        drawCircle(app.player.cx, app.player.cy, app.player.r, fill = 'white', border = 'black')
        drawAllRays(app, app.maxRayLength, app.arcLength)
    else:
        drawWinMessage(app)

def flashlight_redrawAll(app):
    #Draw the board
    if not app.win:
        drawProgressBar(app)
        drawLabel(f'Treasures Collected: {app.score}/{app.treasures}', 200, 40)
        drawRect(app.boardLeft, app.boardTop, app.boardWidth, app.boardHeight, fill = 'black')
        #Draw the player
        drawLabel('v',app.player.cx, app.player.cy, size = app.player.r * 4,
                fill = 'white', rotateAngle = app.facingAngle - 90)
        drawFlashlight(app, app.maxRayLength, app.arcLength)
        #Fill board
        flashlight_drawBoard(app)
    else:
        drawWinMessage(app)

#Colors: https://matplotlib.org/stable/gallery/color/named_colors.html
def firstPerson_redrawAll(app):
    if not app.win:
        #draw background
        drawRect(0, 0, app.width, app.height, fill = gradient('white', 'gray', 'black', start = 'center'))
        drawRect(0, app.height  / 2, app.width, app.height / 2, 
             fill = 'saddleBrown')
        #draw walls
        draw3D(app, app.maxRayLength, app.arcLength)
        drawProgressBar(app)
        #draw compass
        drawCircle(370, 30, 20, fill = 'white')
        drawLabel('v', 370, 30, size = app.player.r * 4,
                fill = 'red', rotateAngle = app.facingAngle - 90)
    else:
        drawWinMessage(app)
    
#Controls
def map_onKeyPress(app, key):
    if key == 'r':
        resetBoard(app)
    if key == 'f':
        setActiveScreen('flashlight')
    if key == 'm':
        setActiveScreen('map')
    if key == 'i':
        setActiveScreen('firstPerson')
    if key == 's':
        setActiveScreen('start')
        resetBoard(app)

def flashlight_onKeyPress(app, key):
    map_onKeyPress(app, key)

def firstPerson_onKeyPress(app, key):
    map_onKeyPress(app, key)
        
def map_onKeyHold(app, key):
    #board based movement, older code
    '''if 'right' in key:
        app.facingAngle += 10
    if 'left' in key:
        app.facingAngle -= 10
    if 'w' in key:
        app.player.dy = -1
    if 's' in key:
        app.player.dy = 1
    if 'w' in key and 's' in key:
        app.player.dy = 0
    if 'a' in key:
        app.player.dx = -1
    if 'd' in key:
        app.player.dx = 1
    if 'a' in key and 'd' in key:
        app.player.dx = 0
    if 'q' in key and app.arcLength > 30:
        app.maxRayLength += 10
        app.arcLength -= 10
    if 'e' in key and app.arcLength < 90:
        app.maxRayLength -= 10
        app.arcLength += 10'''
    firstPerson_onKeyHold(app, key)


def flashlight_onKeyHold(app, key):
    map_onKeyHold(app, key)

def firstPerson_onKeyHold(app, key):
    #player-centered movement
    if 'right' in key:
        app.facingAngle += 20
    if 'left' in key:
        app.facingAngle -= 20
    if 'up' in key:
        app.player.dy = math.sin(math.radians(app.facingAngle))
        app.player.dx = math.cos(math.radians(app.facingAngle))
    if 'down' in key:
        app.player.dy = -math.sin(math.radians(app.facingAngle))
        app.player.dx = -math.cos(math.radians(app.facingAngle))
    if 'up' in key and 'down' in key:
        app.player.dy = 0
        app.player.dx = 0
    if 'q' in key and app.arcLength > 30:
        app.maxRayLength += 10
        app.arcLength -= 10
    if 'e' in key and app.arcLength < 90:
        app.maxRayLength -= 10
        app.arcLength += 10

def map_onKeyRelease(app, key):
    firstPerson_onKeyRelease(app, key)

def flashlight_onKeyRelease(app, key):
    map_onKeyRelease(app, key)

def firstPerson_onKeyRelease(app, key):
    if key == 'up' or key == 'down':
        app.player.dy = 0
        app.player.dx = 0

def map_onStep(app):
    #Move the player
    checkBoundaries(app, app.player.cx, app.player.cy)
    #check if objective is met
    if app.score == app.treasures:
        app.win = True

def flashlight_onStep(app):
    map_onStep(app)
    editFlashlightBoard(app, app.maxRayLength, app.arcLength)

def firstPerson_onStep(app):
    map_onStep(app)

#CS academy grid functions
def map_drawBoard(app):
    for row in range(app.rows):
        for col in range(app.cols):
            map_drawCell(app, row, col)

def flashlight_drawBoard(app):
    for row in range(app.rows):
        for col in range(app.cols):
            flashlight_drawCell(app, row, col)

def map_drawCell(app, row, col):
    cellLeft, cellTop = getCellLeftTop(app, row, col)
    cellWidth, cellHeight = getCellSize(app)
    drawRect(cellLeft, cellTop, cellWidth, cellHeight,
             fill=app.cellColors[row][col])

#flashlight uses different grid to draw than map
def flashlight_drawCell(app, row, col): 
    cellLeft, cellTop = getCellLeftTop(app, row, col)
    cellWidth, cellHeight = getCellSize(app)
    drawRect(cellLeft, cellTop, cellWidth, cellHeight,
             fill=app.flashlightColors[row][col])

def getCell(app, x, y):
    cellWidth, cellHeight = getCellSize(app)
    cellRow = (y - app.boardTop) // cellHeight
    cellCol = (x - app.boardLeft) // cellWidth
    return int(cellRow), int(cellCol)

def getCellLeftTop(app, row, col):
    cellWidth, cellHeight = getCellSize(app)
    cellLeft = app.boardLeft + col * cellWidth
    cellTop = app.boardTop + row * cellHeight
    return (cellLeft, cellTop)

def getCellSize(app):
    cellWidth = app.boardWidth / app.cols
    cellHeight = app.boardHeight / app.rows
    return (cellWidth, cellHeight)

#used together with recursion generation to make it more consistent (map)
def fillBoard(app):
    gridCenter = []
    #finding center of board excluding the border cells
    for row in range(1, app.rows - 1):
        gridCenter += [app.cellColors[row][1:-1]]
    #remake the board with the newly created dungeon
    filledCenter = createDungeon(gridCenter)
    for row in range(1, app.rows - 1):
        app.cellColors[row] = ([app.cellColors[row][0]] + filledCenter[row - 1]
                                + [app.cellColors[row][-1]])
    app.cellColors[app.rows//2 - 1][app.cols//2] = None
    app.cellColors[app.rows//2][app.cols//2] = None


def fillBorders(app):
    for edgeRow in [0, app.rows-1]:
        app.cellColors[edgeRow] = ['green' for col in range(app.cols)]
    for edgeCol in [0, app.cols-1]:
        for row in range(app.rows):
            app.cellColors[row][edgeCol] = 'green'

#Process source: https://www.roguebasin.com/index.php/Basic_BSP_Dungeon_generation
def createDungeon(grid):
    rows, cols = len(grid), len(grid[0])
    borderDistance = random.randint(2, 4)
    if len(grid) > 2 * borderDistance and len(grid[0]) > 2 * borderDistance:
        randomDir = random.choice(['vertical', 'horizontal'])
    elif len(grid) > 2 * borderDistance:
        randomDir = 'horizontal'
    elif len(grid[0]) > 2 * borderDistance:
        randomDir = 'vertical'
    else:
        randomDir = 'None'
    if randomDir == 'None': #basecase
        return grid
    else: #recursivecase
        if randomDir == 'vertical': #draw vertical border
            if borderDistance == len(grid) - borderDistance - 1:
                randomCol = borderDistance
            else:
                randomCol = random.randint(borderDistance, len(grid[0]) - borderDistance - 1)
            #split board into sections
            gridLeft = []
            gridReplace = []
            gridRight = []
            randomPath = random.randint(0, rows-2)
            for row in range(rows):
                gridLeft.append(grid[row][:randomCol])
                if row == randomPath or row == randomPath + 1: 
                    gridReplace.append([None])
                else:
                    gridReplace.append(['green'])
                gridRight.append(grid[row][randomCol + 1:])
            newGridLeft = createDungeon(gridLeft)
            newGridRight = createDungeon(gridRight)
            for row in range(rows): #recursively recreate the board
                grid[row] = newGridLeft[row] + gridReplace[row] + newGridRight[row]
        else: #draw horizontal border
            if borderDistance == len(grid[0]) - borderDistance - 1:
                randomRow = borderDistance
            else:
                randomRow = random.randint(borderDistance, len(grid) - borderDistance - 1)
            midRow = [['green' for col in range(cols)]]
            randomPath = random.randint(0, cols-2)
            midRow[0][randomPath] = None
            midRow[0][randomPath+1] = None
            #recursively create the board by splitting it up
            grid = (createDungeon(grid[0:randomRow]) + 
                    midRow + createDungeon(grid[randomRow+1:]))
        return grid

#Concept from: https://gamedev.stackexchange.com/questions/179635/circle-square-collision-detection-simple-formula
#Idea is to find out how far the center of the circle can be from the square (radius length),
#Then to check if the center is within that distance
#Code is all original
def checkCollisions(circleCenterX, circleCenterY, circleRadius,
                     rectLeftX, rectTopY, rectWidth, rectHeight):
    #Check corner collisions
    rectCorners = [(rectLeftX, rectTopY),(rectLeftX + rectWidth, rectTopY),
                             (rectLeftX, rectTopY+rectHeight),
                             (rectLeftX+rectWidth, rectTopY+rectHeight)]
    for cornerX, cornerY in rectCorners:
        if distance(cornerX, cornerY, circleCenterX, circleCenterY) <= circleRadius:
            return True

    #Check left/right portion collisions
    minX, maxX = rectLeftX - circleRadius, rectLeftX + rectWidth + circleRadius
    if (rectTopY < circleCenterY < rectTopY + rectHeight
        and minX < circleCenterX < maxX):
        return True
    #Check up/down portion collisions
    minY, maxY = rectTopY - circleRadius, rectTopY + rectHeight + circleRadius
    if (rectLeftX < circleCenterX < rectLeftX + rectWidth
        and minY < circleCenterY < maxY):
        return True
    return False

#Used in the above function
def distance(x1, y1, x2, y2):
    return ((x1-x2)**2 + (y1-y2)**2)**0.5

#checks for player collisions, revert movement if wall, erase if collectable object
def checkBoundaries(app, x, y):
    #Double for-loops allow for sliding along walls
    cellRowNum, cellColNum = getCell(app, x, y)
    app.player.cy += app.player.dy * app.movementCoefficient
    #Loops through all cells in a 3x3 square from the point
    for row in range(cellRowNum-1, cellRowNum + 2):
        for col in range(cellColNum-1, cellColNum + 2):
            rectLeftX, rectTopY = getCellLeftTop(app, row, col)
            rectWidth, rectHeight = getCellSize(app)
            isColliding = checkCollisions(app.player.cx, app.player.cy, app.player.r,
                                            rectLeftX, rectTopY, rectWidth, rectHeight)

            if app.cellColors[row][col] != None and isColliding:
                if app.cellColors[row][col] == 'green':
                    while checkCollisions(app.player.cx, app.player.cy, app.player.r,
                                            rectLeftX, rectTopY, rectWidth, rectHeight):
                        app.player.cy -= app.player.dy
                else:
                    app.cellColors[row][col] = None
                    app.score += 1
            
    app.player.cx += app.player.dx * app.movementCoefficient
    for row in range(app.rows):
        for col in range(app.cols):
            rectLeftX, rectTopY = getCellLeftTop(app, row, col)
            rectWidth, rectHeight = getCellSize(app)
            isColliding = checkCollisions(app.player.cx, app.player.cy, app.player.r,
                                            rectLeftX, rectTopY, rectWidth, rectHeight)
            if app.cellColors[row][col] != None and isColliding:
                if app.cellColors[row][col] == 'green':
                    while checkCollisions(app.player.cx, app.player.cy, app.player.r,
                                            rectLeftX, rectTopY, rectWidth, rectHeight):
                        app.player.cx -= app.player.dx
                else:
                    app.cellColors[row][col] = None
                    app.score += 1

#Raytracing stuff: https://lodev.org/cgtutor/raycasting.html
def traceLinePoints(app, maxLength, angle):
    incrementingX, incrementingY = app.player.cx, app.player.cy
    currentLength = 0
    cellRow, cellCol = getCell(app, incrementingX, incrementingY)
    while currentLength < maxLength and app.cellColors[cellRow][cellCol] == None:
        currentLength += 2
        incrementingX += math.cos(math.radians(angle))
        incrementingY += math.sin(math.radians(angle))
        cellRow, cellCol = getCell(app, incrementingX, incrementingY)
    
    return incrementingX, incrementingY, cellRow, cellCol

#some variables are unused so one function can work for all of these
def drawAllRays(app, maxLength, totalAngle):
    for angle in range(0-totalAngle//2, totalAngle//2, totalAngle // 30):
        newPointX, newPointY, cellRow, cellCol = traceLinePoints(app, maxLength, angle + app.facingAngle)
        drawLine(newPointX, newPointY, app.player.cx, app.player.cy, fill = 'red', lineWidth = 0.25)

def editFlashlightBoard(app, maxLength, totalAngle):
    resetFlashlight(app)
    for angle in range(0-totalAngle//2, totalAngle//2, totalAngle // 30):
        newPointX, newPointY, cellRow, cellCol = traceLinePoints(app, maxLength, angle + app.facingAngle)
        if app.cellColors[cellRow][cellCol] != None:
            app.flashlightColors[cellRow][cellCol] = app.cellColors[cellRow][cellCol]

def drawFlashlight(app, maxLength, totalAngle):
    coords = [app.player.cx, app.player.cy]
    for angle in range(0-totalAngle//2, totalAngle//2, totalAngle // 30):
        newPointX, newPointY, cellRow, cellCol = traceLinePoints(app, maxLength, angle + app.facingAngle)
        coords.append(newPointX)
        coords.append(newPointY)
    drawPolygon(*coords, fill = 'yellow')

#draw squares of sizes based on distance for each ray drawn
def draw3D(app, maxLength, totalAngle):
    for angle in range(0-totalAngle//2, totalAngle//2, totalAngle // 30):
        newPointX, newPointY, cellRow, cellCol = traceLinePoints(app, maxLength, angle + app.facingAngle)
        sideLength = (distance(newPointX, newPointY, app.player.cx, app.player.cy) ** (-1)) * 600
        angleRatio = ((angle + (totalAngle / 2)) / (totalAngle / 2))
        xCoord = (angleRatio) / 2 * app.width
        sideWidth = app.width / 30 if sideLength < app.width / 30 else sideLength
        drawRect(xCoord, app.height / 2, sideWidth, sideLength,
                    fill = app.cellColors[cellRow][cellCol], align = 'center')

#place treasure in an empty cell that's not wall or player spawn
def generateTreasure(app, num):
    for box in range(num):
        boxCol, boxRow = random.randint(0, app.cols-1), random.randint(0, app.rows-1)
        while (app.cellColors[boxRow][boxCol] != None and 
               not (boxRow == app.rows//2 and boxCol == app.cols//2)):
            boxCol, boxRow = random.randint(0, app.cols-1), random.randint(0, app.rows-1)
        app.cellColors[boxRow][boxCol] = 'cyan'

def drawProgressBar(app):
    for emptySpot in range(app.treasures):
        drawRect(200-(20 * app.treasures / 2)+ (20 * emptySpot), 50, 20, 20, fill = None, border = 'black')
    for barPercent in range(app.score):
        drawRect(200-(20 * app.treasures / 2)+ (20 * barPercent), 50, 20, 20, fill = 'cyan', border = 'black')

def drawWinMessage(app):
    drawLabel('You Won!', 200, 180, size = 30, fill = 'red')
    drawLabel('Press "s" to go back to the start menu', 200, 230, size = 20, fill = 'red')
    
def main():
    runAppWithScreens(initialScreen='start')
    
main()