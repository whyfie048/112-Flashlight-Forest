from cmu_graphics import *
import random
#Random functions: https://www.w3schools.com/python/module_random.asp

#Player variables
class moveableCharacter():
    def __init__(self, cx, cy, r, dx = 0, dy = 0):
        self.cx = cx
        self.cy = cy
        self.dx = dx
        self.dy = dy
        self.r = r
        
def onAppStart(app):
    #Board variables
    app.rows = 20
    app.cols = 20
    app.boardLeft = 50
    app.boardTop = 75
    app.boardWidth = 300
    app.boardHeight = 300
    resetBoard(app)

def resetBoard(app):
    #Player variables
    cellWidth, cellHeight = getCellSize(app)
    radius = min(cellWidth, cellHeight) // 4
    app.player = moveableCharacter(app.boardLeft + (cellWidth) * (app.cols // 2 + 0.5), app.boardTop + (cellHeight) * (app.rows // 2 + 0.5), radius)
    app.movementCoefficient = 3
    #Create board
    app.cellColors = [[None for col in range(app.cols)] for row in range(app.rows)]
    fillBorders(app)
    gridCenter = []
    #finding center of board excluding the border
    for row in range(1, app.rows - 1):
        gridCenter += [app.cellColors[row][1:-1]]
    #remake the board with the newly created dungeon
    filledCenter = createDungeon(gridCenter)
    for row in range(1, app.rows - 1):
        app.cellColors[row] = [app.cellColors[row][0]] + filledCenter[row - 1] + [app.cellColors[row][-1]]
    app.cellColors[app.rows//2][app.cols//2] = None

def fillBorders(app):
    for edgeRow in [0, app.rows-1]:
        app.cellColors[edgeRow] = ['green' for col in range(app.cols)]
    for edgeCol in [0, app.cols-1]:
        for row in range(app.rows):
            app.cellColors[row][edgeCol] = 'green'

def redrawAll(app):
    #Draw the board
    drawLabel('Flashlight Forest', 200, 30)
    drawBoard(app)
    #Draw the player
    drawCircle(app.player.cx, app.player.cy, app.player.r)

def onKeyPress(app, key):
    if key == 'r':
        resetBoard(app)

def onKeyHold(app, key):
    if 'w' in key:
        app.player.dy = -1
    if 's' in key:
        app.player.dy = 1
    if 'w' in key and 's' in key:
        app.player.dy = 0
    if 'a' in key:
        app.player.dx = -1
    if 'd' in key:
        app.player.dx = 1
    if 'a' in key and 'd' in key:
        app.player.dx = 0

def onKeyRelease(app, key):
    if key == 'w' or key == 's':
        app.player.dy = 0
    if key == 'a' or key == 'd':
        app.player.dx = 0

def onStep(app):
    #Move the player
    app.player.cy += app.player.dy * app.movementCoefficient
    app.player.cx += app.player.dx * app.movementCoefficient
    #Boundary Checks
    collisionFound = False
    for row in range(app.rows):
        for col in range(app.cols):
            if app.cellColors[row][col] == 'green':
                rectLeftX, rectTopY = getCellLeftTop(app, row, col)
                rectWidth, rectHeight = getCellSize(app)
                if checkCollisions(app.player, rectLeftX, rectTopY, rectWidth, rectHeight):
                    app.player.cy -= app.player.dy * app.movementCoefficient
                    app.player.cx -= app.player.dx * app.movementCoefficient
                    collisionFound = True
                    break
        if collisionFound == True:
            break

def drawBoard(app):
    for row in range(app.rows):
        for col in range(app.cols):
            drawCell(app, row, col)

def drawBoardBorder(app):
  # draw the board outline (with double-thickness):
  drawRect(app.boardLeft, app.boardTop, app.boardWidth, app.boardHeight,
           fill=None, border='black',
           borderWidth=2*app.cellBorderWidth)

def drawCell(app, row, col):
    cellLeft, cellTop = getCellLeftTop(app, row, col)
    cellWidth, cellHeight = getCellSize(app)
    drawRect(cellLeft, cellTop, cellWidth, cellHeight,
             fill=app.cellColors[row][col])

def getCellLeftTop(app, row, col):
    cellWidth, cellHeight = getCellSize(app)
    cellLeft = app.boardLeft + col * cellWidth
    cellTop = app.boardTop + row * cellHeight
    return (cellLeft, cellTop)

def getCellSize(app):
    cellWidth = app.boardWidth / app.cols
    cellHeight = app.boardHeight / app.rows
    return (cellWidth, cellHeight)

#Process source: https://www.roguebasin.com/index.php/Basic_BSP_Dungeon_generation
def createDungeon(grid):
    rows, cols = len(grid), len(grid[0])
    borderDistance = random.randint(2, 4)
    if len(grid) > 2 * borderDistance and len(grid[0]) > 2 * borderDistance:
        randomDir = random.choice(['vertical', 'horizontal'])
    elif len(grid) > 2 * borderDistance:
        randomDir = 'horizontal'
    elif len(grid[0]) > 2 * borderDistance:
        randomDir = 'vertical'
    else:
        randomDir = 'None'
    
    if randomDir == 'None': #basecase
        return grid
    else: #recursivecase
        if randomDir == 'vertical': #draw vertical border
            if borderDistance == len(grid) - borderDistance - 1:
                randomCol = borderDistance
            else:
                randomCol = random.randint(borderDistance, len(grid[0]) - borderDistance - 1)
            #split board into sections
            gridLeft = []
            gridReplace = []
            gridRight = []
            randomPath = random.randint(0, rows-2)
            for row in range(rows):
                gridLeft.append(grid[row][:randomCol])
                if row == randomPath or row == randomPath + 1: 
                    gridReplace.append([None])
                else:
                    gridReplace.append(['green'])
                gridRight.append(grid[row][randomCol + 1:])
            newGridLeft = createDungeon(gridLeft)
            newGridRight = createDungeon(gridRight)
            for row in range(rows): #recursively recreate the board
                grid[row] = newGridLeft[row] + gridReplace[row] + newGridRight[row]
        else: #draw horizontal border
            if borderDistance == len(grid[0]) - borderDistance - 1:
                randomRow = borderDistance
            else:
                randomRow = random.randint(borderDistance, len(grid) - borderDistance - 1)
            midRow = [['green' for col in range(cols)]]
            randomPath = random.randint(0, cols-2)
            midRow[0][randomPath] = None
            midRow[0][randomPath+1] = None
            #recursively create the board by splitting it up
            grid = (createDungeon(grid[0:randomRow]) + 
                    midRow + createDungeon(grid[randomRow+1:]))
        return grid
#Concept from: https://gamedev.stackexchange.com/questions/179635/circle-square-collision-detection-simple-formula
def checkCollisions(player, rectLeftX, rectTopY, rectWidth, rectHeight):
    circleRadius = player.r
    shapeCorners = [(rectLeftX, rectTopY - circleRadius), (rectLeftX + rectWidth, rectTopY - circleRadius),
                    (rectLeftX + rectWidth + circleRadius, rectTopY), 
                    (rectLeftX + rectWidth + circleRadius, rectTopY + rectHeight),
                    (rectLeftX + rectWidth, rectTopY + rectHeight + circleRadius),
                    (rectLeftX, rectTopY + rectHeight + circleRadius),
                    (rectLeftX - circleRadius, rectTopY + rectHeight),
                    (rectLeftX - circleRadius, rectTopY)]
    circleCenterX, circleCenterY = player.cx, player.cy
    #Check top portion collisions

    #Check middle portion collisions
    if (shapeCorners[7][0] <= circleCenterX <= shapeCorners[2][0]
        and rectTopY <= circleCenterY <= rectTopY + rectHeight):
        return True
    return False
def main():
    runApp()
    
main()